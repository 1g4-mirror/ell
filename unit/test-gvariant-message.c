/*
 *
 *  Embedded Linux library
 *
 *  Copyright (C) 2011-2014  Intel Corporation. All rights reserved.
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License version 2 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <assert.h>

#include <ell/ell.h>
#include <ell/dbus.h>
#include "ell/dbus-private.h"

static bool do_print = false;

struct message_data {
	const char *type;
	const char *path;
	const char *interface;
	const char *member;
	const char *destination;
	const char *signature;
	const unsigned char *binary;
	size_t binary_len;
};

static const unsigned char basic_1[] = {
	0x6c, 0x01, 0x00, 0x02, 0x28, 0x00, 0x00, 0x00, 0x57, 0x04, 0x00, 0x00,
	0x79, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2f, 0x66, 0x6f, 0x6f, 0x2f, 0x62, 0x61, 0x72, 0x00, 0x00, 0x6f, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x46, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x66, 0x6f, 0x6f, 0x2e, 0x62, 0x61, 0x72, 0x00, 0x00, 0x73, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x66, 0x6f, 0x6f, 0x2e, 0x62, 0x61, 0x72, 0x00, 0x00, 0x73, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x62, 0x79, 0x6e, 0x71, 0x69, 0x75, 0x78, 0x74, 0x64, 0x00, 0x00, 0x67,
	0x13, 0x29, 0x42, 0x5a, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0xff, 0xe0, 0xff, 0x20, 0x00, 0x00, 0x00, 0xe8, 0xff, 0xff, 0xff,
	0x18, 0x00, 0x00, 0x00, 0x9d, 0xff, 0xff, 0xff, 0x7d, 0x7f, 0x00, 0x00,
	0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd3, 0xe4, 0x42, 0x00,
	0x00, 0x00, 0x00, 0x00,
};

static const struct message_data message_data_basic_1 = {
	.type		= "method_call",
	.path		= "/foo/bar",
	.interface	= "foo.bar",
	.member		= "Foobar",
	.destination	= "foo.bar",
	.signature	= "bynqiuxtd",
	.binary		= basic_1,
	.binary_len	= 184,
};

static struct l_dbus_message *check_message(const struct message_data *msg_data)
{
	struct l_dbus_message *msg;

	msg = dbus_message_build(msg_data->binary, msg_data->binary_len);
	assert(msg);

	if (msg_data->destination) {
		const char *destination;

		destination = l_dbus_message_get_destination(msg);
		assert(destination);
		assert(!strcmp(msg_data->destination, destination));

		if (do_print)
			l_info("destination=%s", destination);
	}

	return msg;
}

static void parse_basic_1(const void *data)
{
	struct l_dbus_message *msg = check_message(data);

	l_dbus_message_unref(msg);
}

int main(int argc, char *argv[])
{
	l_test_init(&argc, &argv);

	l_test_add("Basic 1 (parse)", parse_basic_1, &message_data_basic_1);

	return l_test_run();
}
